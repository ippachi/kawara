# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `test-unit` gem.
# Please instead update this file by running `bin/tapioca gem test-unit`.

module Test; end

module Test::Unit
  class << self
    def at_exit(&hook); end
    def at_start(&hook); end
    def run=(have_run); end
    def run?; end
    def run_at_exit_hooks; end
    def run_at_start_hooks; end
  end
end

class Test::Unit::AssertionFailedError < ::StandardError
  def initialize(message = T.unsafe(nil), options = T.unsafe(nil)); end

  def actual; end
  def actual=(_arg0); end
  def expected; end
  def expected=(_arg0); end
  def inspected_actual; end
  def inspected_actual=(_arg0); end
  def inspected_expected; end
  def inspected_expected=(_arg0); end
  def user_message; end
  def user_message=(_arg0); end

  private

  def debug_on_failure; end

  class << self
    def debug_on_failure=(boolean); end
    def debug_on_failure?; end
  end
end

module Test::Unit::Assertions
  def add_assertion; end
  def assert(object = T.unsafe(nil), message = T.unsafe(nil), &block); end
  def assert_alias_method(object, alias_name, original_name, message = T.unsafe(nil)); end
  def assert_all(collection, message = T.unsafe(nil)); end
  def assert_all?(collection, message = T.unsafe(nil)); end
  def assert_block(message = T.unsafe(nil)); end
  def assert_boolean(actual, message = T.unsafe(nil)); end
  def assert_compare(expected, operator, actual, message = T.unsafe(nil)); end
  def assert_const_defined(object, constant_name, message = T.unsafe(nil)); end
  def assert_empty(object, message = T.unsafe(nil)); end
  def assert_equal(expected, actual, message = T.unsafe(nil)); end
  def assert_fail_assertion(message = T.unsafe(nil)); end
  def assert_false(actual, message = T.unsafe(nil)); end
  def assert_in_delta(expected_float, actual_float, delta = T.unsafe(nil), message = T.unsafe(nil)); end
  def assert_in_epsilon(expected_float, actual_float, epsilon = T.unsafe(nil), message = T.unsafe(nil)); end
  def assert_include(collection, object, message = T.unsafe(nil)); end
  def assert_includes(collection, object, message = T.unsafe(nil)); end
  def assert_instance_of(klass, object, message = T.unsafe(nil)); end
  def assert_kind_of(klass, object, message = T.unsafe(nil)); end
  def assert_match(pattern, string, message = T.unsafe(nil)); end
  def assert_nil(object, message = T.unsafe(nil)); end
  def assert_no_match(regexp, string, message = T.unsafe(nil)); end
  def assert_not_const_defined(object, constant_name, message = T.unsafe(nil)); end
  def assert_not_empty(object, message = T.unsafe(nil)); end
  def assert_not_equal(expected, actual, message = T.unsafe(nil)); end
  def assert_not_in_delta(expected_float, actual_float, delta = T.unsafe(nil), message = T.unsafe(nil)); end
  def assert_not_in_epsilon(expected_float, actual_float, epsilon = T.unsafe(nil), message = T.unsafe(nil)); end
  def assert_not_include(collection, object, message = T.unsafe(nil)); end
  def assert_not_includes(collection, object, message = T.unsafe(nil)); end
  def assert_not_instance_of(klass, object, message = T.unsafe(nil)); end
  def assert_not_kind_of(klass, object, message = T.unsafe(nil)); end
  def assert_not_match(pattern, string, message = T.unsafe(nil)); end
  def assert_not_nil(object, message = T.unsafe(nil)); end
  def assert_not_operator(object1, operator, object2, message = T.unsafe(nil)); end
  def assert_not_predicate(object, predicate, message = T.unsafe(nil)); end
  def assert_not_respond_to(object, method, message = T.unsafe(nil)); end
  def assert_not_same(expected, actual, message = T.unsafe(nil)); end
  def assert_not_send(send_array, message = T.unsafe(nil)); end
  def assert_nothing_leaked_memory(max_increasable_size, target = T.unsafe(nil), message = T.unsafe(nil)); end
  def assert_nothing_raised(*args); end
  def assert_nothing_thrown(message = T.unsafe(nil), &proc); end
  def assert_operator(object1, operator, object2, message = T.unsafe(nil)); end
  def assert_path_exist(path, message = T.unsafe(nil)); end
  def assert_path_not_exist(path, message = T.unsafe(nil)); end
  def assert_predicate(object, predicate, message = T.unsafe(nil)); end
  def assert_raise(*args, &block); end
  def assert_raise_kind_of(*args, &block); end
  def assert_raise_message(expected, message = T.unsafe(nil)); end
  def assert_raise_with_message(expected_exception_class, expected_message, message = T.unsafe(nil), &block); end
  def assert_raises(*args, &block); end
  def assert_respond_to(object, method, message = T.unsafe(nil)); end
  def assert_same(expected, actual, message = T.unsafe(nil)); end
  def assert_send(send_array, message = T.unsafe(nil)); end
  def assert_throw(expected_object, message = T.unsafe(nil), &proc); end
  def assert_throws(expected_object, message = T.unsafe(nil), &proc); end
  def assert_true(actual, message = T.unsafe(nil)); end
  def build_message(user_message, template = T.unsafe(nil), *arguments); end
  def flunk(message = T.unsafe(nil)); end
  def refute(object, message = T.unsafe(nil)); end
  def refute_empty(object, message = T.unsafe(nil)); end
  def refute_equal(expected, actual, message = T.unsafe(nil)); end
  def refute_in_delta(expected_float, actual_float, delta = T.unsafe(nil), message = T.unsafe(nil)); end
  def refute_in_epsilon(expected_float, actual_float, epsilon = T.unsafe(nil), message = T.unsafe(nil)); end
  def refute_includes(collection, object, message = T.unsafe(nil)); end
  def refute_instance_of(klass, object, message = T.unsafe(nil)); end
  def refute_kind_of(klass, object, message = T.unsafe(nil)); end
  def refute_match(pattern, string, message = T.unsafe(nil)); end
  def refute_nil(object, message = T.unsafe(nil)); end
  def refute_operator(object1, operator, object2, message = T.unsafe(nil)); end
  def refute_predicate(object, predicate, message = T.unsafe(nil)); end
  def refute_respond_to(object, method, message = T.unsafe(nil)); end
  def refute_same(expected, actual, message = T.unsafe(nil)); end

  private

  def _assert_in_delta_message(expected_float, actual_float, delta, message, options = T.unsafe(nil)); end
  def _assert_in_delta_validate_arguments(expected_float, actual_float, delta); end
  def _assert_in_epsilon_message(expected_float, actual_float, epsilon, message, options = T.unsafe(nil)); end
  def _assert_in_epsilon_validate_arguments(expected_float, actual_float, epsilon); end
  def _assert_raise(assert_expected_exception, *args, &block); end
  def _set_failed_information(failure, expected, actual); end
  def _wrap_assertion(&block); end

  class << self
    def use_pp=(value); end
  end
end

class Test::Unit::Assertions::AssertExceptionHelper
  def initialize(test_case, expected_exceptions); end

  def expected?(actual_exception, equality = T.unsafe(nil)); end
  def expected_exceptions; end

  private

  def exception_class?(exception_type); end
  def exception_object?(exception_type); end
  def expected_class?(actual_exception, equality); end
  def expected_module?(actual_exception); end
  def expected_object?(actual_exception); end
  def fallback_exception_object_equal(expected_object, actual_exception); end
  def split_expected_exceptions(expected_exceptions); end
end

class Test::Unit::Assertions::AssertExceptionHelper::WrappedException
  def initialize(exception); end

  def exception; end
  def inspect; end
  def method_missing(name, *args, &block); end

  private

  def default_inspect?; end
end

class Test::Unit::Assertions::AssertionMessage
  include ::Test::Unit::Util::BacktraceFilter

  def initialize(user_message, template_string, parameters); end

  def convert(object); end
  def template; end
  def to_s; end
  def user_message; end

  private

  def add_period(string); end

  class << self
    def convert(object); end
    def delayed_diff(from, to); end
    def delayed_literal(&block); end
    def diff_target_string?(string); end
    def ensure_diffable_string(string); end
    def literal(value); end
    def max_diff_target_string_size; end
    def max_diff_target_string_size=(size); end
    def maybe_container(value, &formatter); end
    def prepare_for_diff(from, to); end
    def use_pp; end
    def use_pp=(_arg0); end
  end
end

class Test::Unit::Assertions::AssertionMessage::ArrayInspector
  def initialize(array, inspected_objects); end

  def each(&block); end
  def inspect; end
  def pretty_print(q); end
  def pretty_print_cycle(q); end

  class << self
    def target?(object); end
  end
end

class Test::Unit::Assertions::AssertionMessage::DelayedLiteral
  def initialize(value); end

  def inspect; end
end

class Test::Unit::Assertions::AssertionMessage::HashInspector
  def initialize(hash, inspected_objects); end

  def each_pair; end
  def inspect; end
  def pretty_print(q); end
  def pretty_print_cycle(q); end

  class << self
    def target?(object); end
  end
end

class Test::Unit::Assertions::AssertionMessage::Inspector
  include ::Comparable

  def initialize(object, inspected_objects = T.unsafe(nil)); end

  def <=>(other); end
  def inspect; end
  def native_inspect; end
  def object; end
  def pretty_print(q); end
  def pretty_print_cycle(q); end

  private

  def inspect_target; end

  class << self
    def cached_new(object, inspected_objects); end
    def inspector_classes; end
    def register_inspector_class(inspector_class); end
    def unregister_inspector_class(inspector_class); end
  end
end

class Test::Unit::Assertions::AssertionMessage::Literal
  def initialize(value); end

  def inspect; end
end

class Test::Unit::Assertions::AssertionMessage::MaybeContainer
  def initialize(value, &formatter); end

  def inspect; end
end

class Test::Unit::Assertions::AssertionMessage::NumericInspector
  def initialize(numeric, inspected_objects); end

  def inspect; end
  def pretty_print(q); end
  def pretty_print_cycle(q); end

  class << self
    def target?(object); end
  end
end

class Test::Unit::Assertions::AssertionMessage::Template
  def initialize(parts); end

  def count; end
  def result(parameters); end

  private

  def concatenatable(text, encoding); end

  class << self
    def create(string); end
  end
end

Test::Unit::Assertions::NOT_SPECIFIED = T.let(T.unsafe(nil), Object)

class Test::Unit::Assertions::ThrowTagExtractor
  def initialize(error); end

  def extract_tag; end

  private

  def normalize_tag(tag); end
end

Test::Unit::Assertions::ThrowTagExtractor::UncaughtThrowPatterns = T.let(T.unsafe(nil), Hash)

module Test::Unit::Attribute
  mixes_in_class_methods ::Test::Unit::Attribute::BaseClassMethods
  mixes_in_class_methods ::Test::Unit::Attribute::ClassMethods

  def [](name); end
  def attributes; end

  class << self
    def included(base); end
  end
end

module Test::Unit::Attribute::BaseClassMethods
  def attributes_table; end
end

module Test::Unit::Attribute::ClassMethods
  def attribute(name, value, options = T.unsafe(nil), *method_names); end
  def attribute_observers(attribute_name); end
  def attributes(method_name); end
  def attributes_table; end
  def current_attribute(name); end
  def current_attributes; end
  def find_attribute(method_name, name, options = T.unsafe(nil)); end
  def method_added(name); end
  def register_attribute_observer(attribute_name, observer = T.unsafe(nil), &block); end
  def set_attributes(method_name, new_attributes); end
end

class Test::Unit::Attribute::StringifyKeyHash < ::Hash
  def [](key); end
  def []=(key, value); end
  def key?(key); end

  class << self
    def stringify(object); end
  end
end

class Test::Unit::AttributeMatcher
  def initialize(test); end

  def match?(expression); end
  def method_missing(name, *args); end
end

class Test::Unit::AutoRunner
  def initialize(standalone); end

  def base; end
  def base=(_arg0); end
  def collector=(_arg0); end
  def color_scheme; end
  def color_scheme=(_arg0); end
  def debug_on_failure=(_arg0); end
  def debug_on_failure?; end
  def default_test_paths; end
  def default_test_paths=(_arg0); end
  def exclude; end
  def exclude=(_arg0); end
  def filters; end
  def filters=(_arg0); end
  def keyword_display(keywords); end
  def listeners; end
  def listeners=(_arg0); end
  def load_config(file); end
  def options; end
  def pattern; end
  def pattern=(_arg0); end
  def prepare; end
  def process_args(args = T.unsafe(nil)); end
  def run; end
  def runner=(_arg0); end
  def runner_options; end
  def stop_on_failure=(_arg0); end
  def stop_on_failure?; end
  def suite; end
  def to_run; end
  def to_run=(_arg0); end
  def workdir; end
  def workdir=(_arg0); end

  private

  def add_location_filter(path, line); end
  def add_test_path(path); end
  def change_work_directory(&block); end
  def default_collector; end
  def default_runner; end
  def global_config_file; end
  def load_global_config; end
  def match_test_case_name(test, pattern); end
  def match_test_name(test, pattern); end
  def prepare_name(name); end

  class << self
    def collector(id); end
    def default_runner; end
    def default_runner=(id); end
    def need_auto_run=(need); end
    def need_auto_run?; end
    def prepare(hook = T.unsafe(nil), &block); end
    def register_collector(id, collector_builder = T.unsafe(nil), &block); end
    def register_color_scheme(id, scheme); end
    def register_runner(id, runner_builder = T.unsafe(nil), &block); end
    def run(force_standalone = T.unsafe(nil), default_dir = T.unsafe(nil), argv = T.unsafe(nil), &block); end
    def runner(id); end
    def setup_option(option_builder = T.unsafe(nil), &block); end
    def standalone?; end
  end
end

Test::Unit::AutoRunner::ADDITIONAL_OPTIONS = T.let(T.unsafe(nil), Array)
Test::Unit::AutoRunner::COLLECTORS = T.let(T.unsafe(nil), Hash)
Test::Unit::AutoRunner::PREPARE_HOOKS = T.let(T.unsafe(nil), Array)
Test::Unit::AutoRunner::RUNNERS = T.let(T.unsafe(nil), Hash)

class Test::Unit::AutoRunner::StopOnFailureListener
  def attach_to_mediator(mediator); end
end

module Test::Unit::AutoRunnerLoader
  class << self
    def check(test_case, method_name); end
  end
end

class Test::Unit::Color
  def initialize(name, options = T.unsafe(nil)); end

  def +(other); end
  def ==(other); end
  def background?; end
  def bold?; end
  def escape_sequence; end
  def foreground?; end
  def intensity?; end
  def italic?; end
  def name; end
  def sequence; end
  def underline?; end

  class << self
    def parse_256_color(string); end
  end
end

class Test::Unit::Color::Error < ::StandardError; end
Test::Unit::Color::NAMES = T.let(T.unsafe(nil), Array)
class Test::Unit::Color::ParseError < ::Test::Unit::Color::Error; end

class Test::Unit::ColorScheme
  include ::Enumerable

  def initialize(scheme_spec); end

  def [](name); end
  def []=(name, color_spec); end
  def each(&block); end
  def to_hash; end

  private

  def make_color(color_spec); end

  class << self
    def [](id); end
    def []=(id, scheme_or_spec); end
    def all; end
    def available_colors; end
    def default; end
    def default_for_256_colors; end
    def default_for_8_colors; end

    private

    def guess_available_colors_from_colorterm_env; end
    def guess_available_colors_from_term_env; end
    def guess_available_colors_from_vte_version_env; end
  end
end

Test::Unit::ColorScheme::TERM_256 = T.let(T.unsafe(nil), Regexp)

module Test::Unit::Data
  mixes_in_class_methods ::Test::Unit::Data::ClassMethods

  class << self
    def included(base); end
  end
end

module Test::Unit::Data::ClassMethods
  def data(*arguments, &block); end
  def load_data(file_name); end
end

class Test::Unit::Data::ClassMethods::Loader
  def initialize(test_case); end

  def load(file_name); end
  def load_csv(file_name); end
  def load_tsv(file_name); end

  private

  def normalize_value(value); end
  def set_test_data(header, row); end
end

class Test::Unit::DataSets
  def initialize; end

  def <<(data_set); end
  def ==(other); end
  def add(data_set, options = T.unsafe(nil)); end
  def each; end
  def eql?(other); end
  def hash; end
  def have_keep?; end
  def keep; end

  private

  def each_data_set(&block); end
  def each_pattern(variables); end
  def each_raw_pattern(variables, &block); end
end

module Test::Unit::Diff
  private

  def diff(differ_class, from, to, options = T.unsafe(nil)); end
  def fold(string); end
  def folded_readable(from, to, options = T.unsafe(nil)); end
  def need_fold?(diff); end
  def readable(from, to, options = T.unsafe(nil)); end
  def unified(from, to, options = T.unsafe(nil)); end

  class << self
    def diff(differ_class, from, to, options = T.unsafe(nil)); end
    def fold(string); end
    def folded_readable(from, to, options = T.unsafe(nil)); end
    def need_fold?(diff); end
    def readable(from, to, options = T.unsafe(nil)); end
    def unified(from, to, options = T.unsafe(nil)); end
  end
end

class Test::Unit::Diff::Differ
  def initialize(from, to); end

  private

  def tag(mark, contents); end
end

class Test::Unit::Diff::ReadableDiffer < ::Test::Unit::Diff::Differ
  def diff(options = T.unsafe(nil)); end

  private

  def _diff_lines(from_start, from_end, to_start, to_end); end
  def compute_width(line, start, _end); end
  def cut_off_ratio; end
  def default_ratio; end
  def diff_line(from_line, to_line); end
  def diff_lines(from_start, from_end, to_start, to_end); end
  def find_diff_line_info(from_start, from_end, to_start, to_end); end
  def format_diff_point(from_line, to_line, from_tags, to_tags); end
  def line_operations(from_line, to_line); end
  def n_leading_characters(string, character); end
  def operations; end
  def space_character?(character); end
  def tag(mark, contents); end
  def tag_deleted(contents); end
  def tag_difference(contents); end
  def tag_equal(contents); end
  def tag_inserted(contents); end
end

class Test::Unit::Diff::SequenceMatcher
  def initialize(from, to, &junk_predicate); end

  def blocks; end
  def grouped_operations(context_size = T.unsafe(nil)); end
  def longest_match(from_start, from_end, to_start, to_end); end
  def operations; end
  def ratio; end

  private

  def adjust_best_info_with_junk_predicate(should_junk, best_info, from_start, from_end, to_start, to_end); end
  def compute_blocks; end
  def compute_matches; end
  def compute_operations; end
  def compute_ratio; end
  def determine_tag(from_index, to_index, match_from_index, match_to_index); end
  def expand_edge_equal_operations!(_operations, context_size); end
  def find_best_match_position(from_start, from_end, to_start, to_end); end
  def matches; end
  def update_to_indexes; end
end

class Test::Unit::Diff::UTF8Line
  def initialize(line); end

  def [](*args); end
  def compute_width(start, _end); end
  def each(&block); end
  def size; end
  def to_s; end

  class << self
    def wide_character?(character); end

    private

    def binary_search_ranges(character, ranges); end
  end
end

class Test::Unit::Diff::UnifiedDiffer < ::Test::Unit::Diff::Differ
  def diff(options = T.unsafe(nil)); end

  private

  def define_line?(line); end
  def find_interesting_line(from_start, to_start, predicate); end
  def format_summary(operations, show_context); end
  def same_content?(groups); end
end

class Test::Unit::Error
  include ::Test::Unit::Util::BacktraceFilter

  def initialize(test_name, exception, options = T.unsafe(nil)); end

  def backtrace; end
  def critical?; end
  def exception; end
  def label; end
  def location; end
  def long_display; end
  def message; end
  def method_name; end
  def short_display; end
  def single_character_display; end
  def test_name; end
  def to_s; end
end

Test::Unit::Error::LABEL = T.let(T.unsafe(nil), String)
Test::Unit::Error::SINGLE_CHARACTER = T.let(T.unsafe(nil), String)

module Test::Unit::ErrorHandler
  private

  def add_error(exception); end
  def handle_all_exception(exception); end
  def pass_through_exception?(exception); end

  class << self
    def included(base); end
  end
end

Test::Unit::ErrorHandler::NOT_PASS_THROUGH_EXCEPTIONS = T.let(T.unsafe(nil), Array)
Test::Unit::ErrorHandler::NOT_PASS_THROUGH_EXCEPTION_NAMES = T.let(T.unsafe(nil), Array)
Test::Unit::ErrorHandler::PASS_THROUGH_EXCEPTIONS = T.let(T.unsafe(nil), Array)
Test::Unit::ErrorHandler::PASS_THROUGH_EXCEPTION_NAMES = T.let(T.unsafe(nil), Array)

module Test::Unit::ExceptionHandler
  mixes_in_class_methods ::Test::Unit::ExceptionHandler::ClassMethods

  class << self
    def exception_handlers; end
    def included(base); end
  end
end

module Test::Unit::ExceptionHandler::ClassMethods
  def exception_handler(*method_name_or_handlers, &block); end
  def exception_handlers; end
  def unregister_exception_handler(*method_name_or_handlers); end
end

class Test::Unit::Failure
  def initialize(test_name, location, message, options = T.unsafe(nil)); end

  def actual; end
  def critical?; end
  def diff; end
  def expected; end
  def inspected_actual; end
  def inspected_expected; end
  def label; end
  def location; end
  def long_display; end
  def message; end
  def method_name; end
  def short_display; end
  def single_character_display; end
  def source_location; end
  def test_name; end
  def to_s; end
  def user_message; end

  private

  def compute_diff; end
end

Test::Unit::Failure::LABEL = T.let(T.unsafe(nil), String)
Test::Unit::Failure::SINGLE_CHARACTER = T.let(T.unsafe(nil), String)

module Test::Unit::FailureHandler
  def add_failure(message, backtrace, options = T.unsafe(nil)); end

  private

  def handle_assertion_failed_error(exception); end

  class << self
    def included(base); end
  end
end

module Test::Unit::Fixture
  mixes_in_class_methods ::Test::Unit::Fixture::ClassMethods

  private

  def create_fixtures_runner(fixtures, options, &block); end
  def run_cleanup; end
  def run_fixture(type, options = T.unsafe(nil), &block); end
  def run_fixture_callback(method_name, options, &block); end
  def run_setup(&block); end
  def run_teardown; end

  class << self
    def included(base); end
  end
end

module Test::Unit::Fixture::ClassMethods
  def cleanup(*method_names, &callback); end
  def fixture; end
  def setup(*method_names, &callback); end
  def teardown(*method_names, &callback); end
  def unregister_cleanup(*method_names_or_callbacks); end
  def unregister_setup(*method_names_or_callbacks); end
  def unregister_teardown(*method_names_or_callbacks); end

  private

  def register_fixture(fixture, *method_names, &callback); end
  def unregister_fixture(fixture, *method_names_or_callbacks); end
end

class Test::Unit::Fixture::Fixture
  def initialize(test_case); end

  def [](type); end
  def after_callbacks(type); end
  def before_callbacks(type); end
  def cleanup; end
  def setup; end
  def teardown; end

  private

  def collect_after_callbacks(type); end
  def collect_before_callbacks(type); end
  def collect_target_test_cases; end
  def merge_callbacks(prepend_callbacks, append_callbacks); end
  def target_test_cases; end
end

class Test::Unit::Fixture::HookPoint
  def initialize(test_case, type, default_options); end

  def after_append_callbacks; end
  def after_prepend_callbacks; end
  def before_append_callbacks; end
  def before_prepend_callbacks; end
  def register(method_name_or_callback, options = T.unsafe(nil)); end
  def unregister(method_name_or_callback); end

  private

  def add_callback(method_name_or_callback, before_how, after_how); end
  def callback_method_name(callback); end
  def valid_register_options?(options); end
end

class Test::Unit::MixColor
  def initialize(colors); end

  def +(other); end
  def ==(other); end
  def colors; end
  def escape_sequence; end
  def sequence; end
end

class Test::Unit::Notification
  include ::Test::Unit::Util::BacktraceFilter

  def initialize(test_name, location, message, options = T.unsafe(nil)); end

  def critical?; end
  def label; end
  def location; end
  def long_display; end
  def message; end
  def method_name; end
  def short_display; end
  def single_character_display; end
  def test_name; end
  def to_s; end
end

Test::Unit::Notification::LABEL = T.let(T.unsafe(nil), String)
Test::Unit::Notification::SINGLE_CHARACTER = T.let(T.unsafe(nil), String)

module Test::Unit::NotificationHandler
  private

  def handle_notified_error(exception); end

  class << self
    def included(base); end
  end
end

class Test::Unit::NotifiedError < ::StandardError; end

class Test::Unit::Omission
  include ::Test::Unit::Util::BacktraceFilter

  def initialize(test_name, location, message, options = T.unsafe(nil)); end

  def critical?; end
  def label; end
  def location; end
  def long_display; end
  def message; end
  def method_name; end
  def short_display; end
  def single_character_display; end
  def test_name; end
  def to_s; end
end

Test::Unit::Omission::LABEL = T.let(T.unsafe(nil), String)
Test::Unit::Omission::SINGLE_CHARACTER = T.let(T.unsafe(nil), String)

module Test::Unit::OmissionHandler
  private

  def handle_omitted_error(exception); end

  class << self
    def included(base); end
  end
end

class Test::Unit::OmittedError < ::StandardError; end
class Test::Unit::PendedError < ::StandardError; end

class Test::Unit::Pending
  include ::Test::Unit::Util::BacktraceFilter

  def initialize(test_name, location, message, options = T.unsafe(nil)); end

  def critical?; end
  def label; end
  def location; end
  def long_display; end
  def message; end
  def method_name; end
  def short_display; end
  def single_character_display; end
  def test_name; end
  def to_s; end
end

Test::Unit::Pending::LABEL = T.let(T.unsafe(nil), String)
Test::Unit::Pending::SINGLE_CHARACTER = T.let(T.unsafe(nil), String)

module Test::Unit::PendingHandler
  private

  def handle_pended_error(exception); end

  class << self
    def included(base); end
  end
end

module Test::Unit::Priority
  mixes_in_class_methods ::Test::Unit::Priority::ClassMethods

  def priority_setup; end
  def priority_teardown; end

  class << self
    def available_values; end
    def default; end
    def default=(default); end
    def disable; end
    def enable; end
    def enabled?; end
    def included(base); end
  end
end

class Test::Unit::Priority::Checker
  def initialize(test); end

  def need_to_run?; end
  def setup; end
  def teardown; end
  def test; end

  private

  def escape_class_name(class_name); end
  def escape_name(name); end
  def escaped_method_name; end
  def passed_file; end
  def previous_test_success?; end
  def result_dir; end

  class << self
    def available_priorities; end
    def have_priority?(name); end
    def need_to_run?(test); end
    def run_priority_high?(test); end
    def run_priority_important?(test); end
    def run_priority_low?(test); end
    def run_priority_must?(test); end
    def run_priority_never?(test); end
    def run_priority_normal?(test); end

    private

    def priority_check_method_name(priority_name); end
  end
end

module Test::Unit::Priority::ClassMethods
  def priority(name, *tests); end
end

class Test::Unit::TestCase
  include ::Test::Unit::Attribute
  include ::Test::Unit::Fixture
  include ::Test::Unit::ExceptionHandler
  include ::Test::Unit::ErrorHandler
  include ::Test::Unit::FailureHandler
  include ::Test::Unit::TestCasePendingSupport
  include ::Test::Unit::PendingHandler
  include ::Test::Unit::TestCaseOmissionSupport
  include ::Test::Unit::OmissionHandler
  include ::Test::Unit::TestCaseNotificationSupport
  include ::Test::Unit::NotificationHandler
  include ::Test::Unit::Priority
  include ::Test::Unit::Data
  include ::Test::Unit::Assertions
  include ::Test::Unit::Util::BacktraceFilter
  include ::Test::Unit::Util::Output
  extend ::Test::Unit::Attribute::BaseClassMethods
  extend ::Test::Unit::Attribute::ClassMethods
  extend ::Test::Unit::Fixture::ClassMethods
  extend ::Test::Unit::ExceptionHandler::ClassMethods
  extend ::Test::Unit::Priority::ClassMethods
  extend ::Test::Unit::Data::ClassMethods

  def initialize(test_method_name); end

  def ==(other); end
  def add_pass; end
  def assign_test_data(label, data); end
  def cleanup; end
  def data; end
  def data_label; end
  def default_test; end
  def description; end
  def elapsed_time; end
  def interrupted?; end
  def local_name; end
  def method_name; end
  def name; end
  def passed?; end
  def problem_occurred; end
  def run(result); end
  def setup; end
  def size; end
  def start_time; end
  def teardown; end
  def to_s; end
  def valid?; end

  private

  def add_assertion; end
  def current_result; end
  def handle_exception(exception); end
  def run_test; end

  class << self
    def added_method_names; end
    def description(value, target = T.unsafe(nil)); end
    def find_locations(query); end
    def include(*modules, &block); end
    def inherited(sub_class); end
    def method_added(name); end
    def ractor(options = T.unsafe(nil)); end
    def shutdown; end
    def startup; end
    def sub_test_case(name, &block); end
    def suite; end
    def test(*test_description_or_targets, &block); end
    def test_defined?(query); end
    def test_order; end
    def test_order=(order); end

    private

    def add_method_location(location); end
    def method_locations; end
    def sub_test_case_class(name); end
    def target_method_locations(path); end
  end
end

Test::Unit::TestCase::AVAILABLE_ORDERS = T.let(T.unsafe(nil), Array)
Test::Unit::TestCase::DESCENDANTS = T.let(T.unsafe(nil), Array)
Test::Unit::TestCase::FINISHED = T.let(T.unsafe(nil), String)
Test::Unit::TestCase::FINISHED_OBJECT = T.let(T.unsafe(nil), String)

class Test::Unit::TestCase::InternalData
  def initialize; end

  def assign_test_data(label, data); end
  def elapsed_time; end
  def have_test_data?; end
  def interrupted; end
  def interrupted?; end
  def passed?; end
  def problem_occurred; end
  def start_time; end
  def test_data; end
  def test_data_label; end
  def test_finished; end
  def test_started; end
end

Test::Unit::TestCase::STARTED = T.let(T.unsafe(nil), String)
Test::Unit::TestCase::STARTED_OBJECT = T.let(T.unsafe(nil), String)

module Test::Unit::TestCaseNotificationSupport
  include ::Test::Unit::NotificationHandler

  def notify(message, options = T.unsafe(nil), &block); end

  private

  def add_notification(notification); end

  class << self
    def included(base); end
  end
end

module Test::Unit::TestCaseOmissionSupport
  include ::Test::Unit::OmissionHandler

  def omit(message = T.unsafe(nil), &block); end
  def omit_if(condition, *args, &block); end
  def omit_unless(condition, *args, &block); end

  private

  def add_omission(omission); end

  class << self
    def included(base); end
  end
end

module Test::Unit::TestCasePendingSupport
  include ::Test::Unit::PendingHandler

  def pend(message = T.unsafe(nil), &block); end

  private

  def add_pending(pending); end

  class << self
    def included(base); end
  end
end

module Test::Unit::TestResultErrorSupport
  def add_error(error); end
  def error_count; end
  def error_occurred?; end
  def errors; end

  private

  def error_summary; end
  def initialize_containers; end
end

module Test::Unit::TestResultFailureSupport
  def add_failure(failure); end
  def failure_count; end
  def failure_occurred?; end
  def failures; end

  private

  def failure_summary; end
  def initialize_containers; end
end

module Test::Unit::TestResultNotificationSupport
  def add_notification(notification); end
  def notification_count; end
  def notifications; end

  private

  def initialize_containers; end
  def notification_summary; end
end

module Test::Unit::TestResultOmissionSupport
  def add_omission(omission); end
  def omission_count; end
  def omissions; end

  private

  def initialize_containers; end
  def omission_summary; end
end

module Test::Unit::TestResultPendingSupport
  def add_pending(pending); end
  def pending_count; end
  def pendings; end

  private

  def initialize_containers; end
  def pending_summary; end
end

class Test::Unit::TestSuite
  def initialize(name = T.unsafe(nil), test_case = T.unsafe(nil)); end

  def <<(test); end
  def ==(other); end
  def delete(test); end
  def delete_tests(tests); end
  def elapsed_time; end
  def empty?; end
  def name; end
  def passed?; end
  def priority; end
  def priority=(_arg0); end
  def run(result, &progress_block); end
  def size; end
  def start_time; end
  def test_case; end
  def tests; end
  def to_s; end

  private

  def handle_exception(exception, result); end
  def run_shutdown(result); end
  def run_startup(result); end
  def run_test(test, result); end
end

Test::Unit::TestSuite::FINISHED = T.let(T.unsafe(nil), String)
Test::Unit::TestSuite::FINISHED_OBJECT = T.let(T.unsafe(nil), String)
Test::Unit::TestSuite::STARTED = T.let(T.unsafe(nil), String)
Test::Unit::TestSuite::STARTED_OBJECT = T.let(T.unsafe(nil), String)

class Test::Unit::TestSuiteCreator
  def initialize(test_case); end

  def create; end

  private

  def append_test(suite, test_name); end
  def collect_test_names; end
  def extract_data_sets(test_name); end
  def sort_test_names_in_alphabetic_order(test_names); end
  def sort_test_names_in_defined_order(test_names); end
  def sort_test_names_in_random_order(test_names); end

  class << self
    def test_method?(test_case, method_name); end
  end
end

module Test::Unit::Util; end

module Test::Unit::Util::BacktraceFilter
  private

  def filter_backtrace(backtrace, prefix = T.unsafe(nil)); end

  class << self
    def filter_backtrace(backtrace, prefix = T.unsafe(nil)); end
  end
end

Test::Unit::Util::BacktraceFilter::POWERASSERT_PREFIX = T.let(T.unsafe(nil), Array)
Test::Unit::Util::BacktraceFilter::TESTUNIT_FILE_SEPARATORS = T.let(T.unsafe(nil), Regexp)
Test::Unit::Util::BacktraceFilter::TESTUNIT_PREFIX = T.let(T.unsafe(nil), Array)
Test::Unit::Util::BacktraceFilter::TESTUNIT_RB_FILE = T.let(T.unsafe(nil), Regexp)

class Test::Unit::Util::MemoryUsage
  def initialize; end

  def collected?; end
  def physical; end
  def virtual; end

  private

  def collect_data; end
  def collect_data_proc; end
end

module Test::Unit::Util::MethodOwnerFinder
  private

  def find(object, method_name); end

  class << self
    def find(object, method_name); end
  end
end

module Test::Unit::Util::Output
  def capture_output; end
end
